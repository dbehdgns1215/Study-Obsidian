---
sticker: emoji//1f4c3
---
# 섹션 2 - 인터넷 네트워크


## 인터넷 통신

**인터넷 상에서 컴퓨터 둘은 어떻게 통신할까?
![[Pasted image 20250110230849.png]]

---

## IP(인터넷 프로토콜)

**복잡한 인터넷 망
최소한의 규칙이 필요한데, 그건 바로 IP 주소 부여

**IP
인터넷 프로토콜 역할
- 지정한 IP주소에 데이터 전달
- 패킷이라는 통신 단위로 데이터 전달

**IP 패킷 정보
출발지 IP + 목적지 IP + ...

패킷을 던지면 인터넷에 있는 노드에게 전달하게 되고 노드들이 서로 통신하면서 도착지까지 도달하는 구조

**IP 프로토콜의 한계
- 비연결성
	- 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- 비신뢰성
	- 중간에 패킷이 사라지면? -> 소실되도 알 수 없음
	- 패킷이 순서대로 안오면? -> 1500byte쯤 되면 끊어서 보내게 됨
- 프로그램 구분
	- 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

### 해결방법
-> TCP/UDP 프로토콜

---

## TCP, UDP

### 인터넷 프로토콜 스택의 4계층

![[Pasted image 20250110233230.png]]


## **TCP
![[Pasted image 20250110231621.png]]

### **TCP/IP 패킷 정보
 ![[Pasted image 20250110231804.png]]

**TCP
전송 제어 프로토콜(Transmission Control Protocol)

- 연결지향 - TCP 3 way handshake(가상 연결)
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜
- 현재는 대부분 TCP 사용 중

### **TCP 3 way handshake
![[Pasted image 20250110231920.png]]
- 클라이언트, 서버 모두 서로에게 SYNC를 보내고 ACK를 보내는 구조
- 받았어? -> 응 -> 내 대답 받았어? -> 응 -> 실제 데이터 전송

**중요한 것은 이 방법을 통해서 실제로(물리적으로) 연결된 것이 아니라는 것.
-> 논리적으로 연결된 것

### **데이터 전달 보증
![[Pasted image 20250110232242.png]]



### **순서보장
![[Pasted image 20250110232308.png]]
- 기본적으로 문제가 생긴 지점부터 싹다 버린 뒤 그 부분부터 재전송을 요청함
- 물론 서버에서 내부적으로 최적화하면 해결이 가능하긴 함

**이게 왜 가능한가?
-> TCP/IP 패킷 정보를 보면 전송 제어 정보, 순서 정보, 검증 정보 등이 포함되어 있기 떄문
![[Pasted image 20250110232457.png]]

## **UDP
사용자 데이터그램 프로토콜(User Datagram Protocol)

- 하얀 도화지에 비유(기능이 거의 없음)
- 연결지향 X (TCP 3 way handshake X)
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고빠름
- ##### **정리
	- IP와 거의 같고 PORT (출발지 도착지) 정보, 체크섬(검증 데이터) 정도만 더 추가된 정도
	- 애플리케이션에서 추가적인 작업이 필요함

시간이 지나면서 사실은 영상 전송까지 거의 모든 걸 TCP가 했었는데, 이제는 UDP가 다시금 떠오르는 중.

웹 브라우저에서 HTTP 통신할 때 사용하는 HTTP 3의 스펙이 공개되었는데, 여기서 TCP/IP handshaking 과 관련해서 SYN 보내고 ACK 보내고 하는 것들까지 줄여서 최적화해보자 하는 움직임으로 UDP 프로토콜을 사용했었기 때문.

---

## **PORT
**한번에 둘 이상 연결해야 한다면?
![[Pasted image 20250110233656.png]]

여러 패킷들이 날라올텐데, 이게 게임에서 필요한 패킷인지 화상통화에서 필요한 패킷인지, 웹 브라우저에 응답 결과로 오는 패킷인지 구별할 수가 없음.

마찬가지로 보낼 때도 문제가 남게 됨.

이를 보완하기 위해서 IP에다가 '포트'라는 개념을 더해주는 것. (출발지 PORT, 목적지 PORT)
- IP는 '목적지 서버'를 찾는 것이고 서버 안에서 돌아가는 애플리케이션들을 구분하는 게 PORT

### TCP/IP 패킷

![[Pasted image 20250110234046.png]]

### PORT - 같은 IP 내에서 프로세스 구분

![[Pasted image 20250110234118.png]]
**EXAMPLE
- 200.200.200.2:11220 (게임 서버 연결)
- 200.200.200.2:32202 (화상통화 통신)
- 200.200.200.3:80 (웹 브라우저 요청)
- 100.100.100.1:10010 (웹 브라우저 요청 응답 {html})
- -> TCP/IP 패킷에는 출발지 정보도 있기 때문에 서버에서도 클라이언트에게 정확히 응답 가능

### PORT

- 0 ~ 65535 : 할당 가능
- 0 ~ 1023 : 잘 알려진 포트, 사용하는 것을 지양
	- FTP : 20, 21
	- TELNET : 23
	- HTTP : 80
	- HTTPS : 443

 

---

## DNS
**WHY USING DNS?

**IP는 기억하기 어렵다
![[Pasted image 20250110235056.png]]


**IP는 변경될 수 있다
![[Pasted image 20250110235219.png]]

### **DNS
도메인 네임 시스템 (Domain Name System)

- 전화번호부
- 도메인 명을 IP 주소로 변환

### **DNS 사용

![[Pasted image 20250110235337.png]]

- DNS 서버에 도메인을 구매해서 등록할 수 있음
- 복잡한 IP 주소 대신, 도메인 명으로 요청 가능
- 우선 도메인 명을 이용해서 DNS 서버에 요청을 보내면, DNS 서버는 해당 도메인 명과 매핑되는 IP 주소를 응답해주고, 이를 클라이언트에서 자동으로 적용해서 서버로 연결되게끔 하는 방식
- 따라서 IP 주소가 변경되더라도 DNS 서버에서만 변경해주면 클라이언트의 입장에서는 일관된 접근이 가능해지는 것

---

# 섹션 3 - URI와 웹 브라우저 요청 흐름


## URI
Uniform Resource Identifier

**URI? URL? URN?

- **URI는 로케이터(Locator), 이름(Name) 또는 둘 다 추가로 분류될 수 있다.
![[Pasted image 20250111214703.png]]



## 웹 브라우저 요청 흐름


---

# 섹션 4 - HTTP 기본

## 모든 것이 HTTP
## 클라이언트 서버 구조
## Stateful, Stateless
## 비 연결성(connectionless)
## HTTP 메시지

---
# 섹션 5 - HTTP 메서드


## HTTP API를 만들어보자
## HTTP 메서드 - GET, POST
## HTTP 메서드 - PUT, PATCH, DELETE
## HTTP 메서드의 속성

---

# 섹션 6 - 

## 제목

---

# 섹션 7 - 

## 제목

---

# 섹션 8 - 

## 제목

---

# 섹션 9 - 

## 제목

---
