---
sticker: emoji//1f4c3
---
1.  **섹션 바로가기
2. [섹션 2 - 인터넷 네트워크](#섹션 2 - 인터넷 네트워크)
3. [섹션 3 - URI와 웹 브라우저 요청 흐름](# 섹션 3 - URI와 웹 브라우저 요청 흐름)
4. 


# 섹션 2 - 인터넷 네트워크


## 인터넷 통신

**인터넷 상에서 컴퓨터 둘은 어떻게 통신할까?
![[Pasted image 20250110230849.png]]

---

## IP(인터넷 프로토콜)

**복잡한 인터넷 망
최소한의 규칙이 필요한데, 그건 바로 IP 주소 부여

**IP
인터넷 프로토콜 역할
- 지정한 IP주소에 데이터 전달
- 패킷이라는 통신 단위로 데이터 전달

**IP 패킷 정보
출발지 IP + 목적지 IP + ...

패킷을 던지면 인터넷에 있는 노드에게 전달하게 되고 노드들이 서로 통신하면서 도착지까지 도달하는 구조

**IP 프로토콜의 한계
- 비연결성
	- 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- 비신뢰성
	- 중간에 패킷이 사라지면? -> 소실되도 알 수 없음
	- 패킷이 순서대로 안오면? -> 1500byte쯤 되면 끊어서 보내게 됨
- 프로그램 구분
	- 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

### 해결방법
-> TCP/UDP 프로토콜

---

## TCP, UDP

### 인터넷 프로토콜 스택의 4계층

![[Pasted image 20250110233230.png]]


## **TCP
![[Pasted image 20250110231621.png]]

### **TCP/IP 패킷 정보
 ![[Pasted image 20250110231804.png]]

**TCP
전송 제어 프로토콜(Transmission Control Protocol)

- 연결지향 - TCP 3 way handshake(가상 연결)
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜
- 현재는 대부분 TCP 사용 중

### **TCP 3 way handshake
![[Pasted image 20250110231920.png]]
- 클라이언트, 서버 모두 서로에게 SYNC를 보내고 ACK를 보내는 구조
- 받았어? -> 응 -> 내 대답 받았어? -> 응 -> 실제 데이터 전송

**중요한 것은 이 방법을 통해서 실제로(물리적으로) 연결된 것이 아니라는 것.
-> 논리적으로 연결된 것

### **데이터 전달 보증
![[Pasted image 20250110232242.png]]



### **순서보장
![[Pasted image 20250110232308.png]]
- 기본적으로 문제가 생긴 지점부터 싹다 버린 뒤 그 부분부터 재전송을 요청함
- 물론 서버에서 내부적으로 최적화하면 해결이 가능하긴 함

**이게 왜 가능한가?
-> TCP/IP 패킷 정보를 보면 전송 제어 정보, 순서 정보, 검증 정보 등이 포함되어 있기 떄문
![[Pasted image 20250110232457.png]]

## **UDP
사용자 데이터그램 프로토콜(User Datagram Protocol)

- 하얀 도화지에 비유(기능이 거의 없음)
- 연결지향 X (TCP 3 way handshake X)
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고빠름
- ##### **정리
	- IP와 거의 같고 PORT (출발지 도착지) 정보, 체크섬(검증 데이터) 정도만 더 추가된 정도
	- 애플리케이션에서 추가적인 작업이 필요함

시간이 지나면서 사실은 영상 전송까지 거의 모든 걸 TCP가 했었는데, 이제는 UDP가 다시금 떠오르는 중.

웹 브라우저에서 HTTP 통신할 때 사용하는 HTTP 3의 스펙이 공개되었는데, 여기서 TCP/IP handshaking 과 관련해서 SYN 보내고 ACK 보내고 하는 것들까지 줄여서 최적화해보자 하는 움직임으로 UDP 프로토콜을 사용했었기 때문.

---

## **PORT
**한번에 둘 이상 연결해야 한다면?
![[Pasted image 20250110233656.png]]

여러 패킷들이 날라올텐데, 이게 게임에서 필요한 패킷인지 화상통화에서 필요한 패킷인지, 웹 브라우저에 응답 결과로 오는 패킷인지 구별할 수가 없음.

마찬가지로 보낼 때도 문제가 남게 됨.

이를 보완하기 위해서 IP에다가 '포트'라는 개념을 더해주는 것. (출발지 PORT, 목적지 PORT)
- IP는 '목적지 서버'를 찾는 것이고 서버 안에서 돌아가는 애플리케이션들을 구분하는 게 PORT

### TCP/IP 패킷

![[Pasted image 20250110234046.png]]

### PORT - 같은 IP 내에서 프로세스 구분

![[Pasted image 20250110234118.png]]
**EXAMPLE
- 200.200.200.2:11220 (게임 서버 연결)
- 200.200.200.2:32202 (화상통화 통신)
- 200.200.200.3:80 (웹 브라우저 요청)
- 100.100.100.1:10010 (웹 브라우저 요청 응답 {html})
- -> TCP/IP 패킷에는 출발지 정보도 있기 때문에 서버에서도 클라이언트에게 정확히 응답 가능

### PORT

- 0 ~ 65535 : 할당 가능
- 0 ~ 1023 : 잘 알려진 포트, 사용하는 것을 지양
	- FTP : 20, 21
	- TELNET : 23
	- HTTP : 80
	- HTTPS : 443

 

---

## DNS
**WHY USING DNS?

**IP는 기억하기 어렵다
![[Pasted image 20250110235056.png]]


**IP는 변경될 수 있다
![[Pasted image 20250110235219.png]]

### **DNS
도메인 네임 시스템 (Domain Name System)

- 전화번호부
- 도메인 명을 IP 주소로 변환

### **DNS 사용

![[Pasted image 20250110235337.png]]

- DNS 서버에 도메인을 구매해서 등록할 수 있음
- 복잡한 IP 주소 대신, 도메인 명으로 요청 가능
- 우선 도메인 명을 이용해서 DNS 서버에 요청을 보내면, DNS 서버는 해당 도메인 명과 매핑되는 IP 주소를 응답해주고, 이를 클라이언트에서 자동으로 적용해서 서버로 연결되게끔 하는 방식
- 따라서 IP 주소가 변경되더라도 DNS 서버에서만 변경해주면 클라이언트의 입장에서는 일관된 접근이 가능해지는 것

---

# 섹션 3 - URI와 웹 브라우저 요청 흐름


## URI
Uniform Resource Identifier

**URI? URL? URN?

- **URI는 로케이터(Locator), 이름(Name) 또는 둘 다 추가로 분류될 수 있다.
![[Pasted image 20250111214703.png]]

![[Pasted image 20250111214809.png]]

**URI
- **U**niform: 리소스를 식별하는 통일된 방식
- **R**esource: 자원, URI로 식별할 수 있는 모든 것 (제한 없음)
- **I**dentifier: 다른 항목과 구분하는데 필요한 정보

**URL
-  Locator: 리소스가 있는 위치를 지정

**URN
- Name: 리소스에 이름을 부여

위치는 변할 수 있지만, 이름은 변하지 않는다.

- *url:isbn:12345678(어떤 책의 isbn URN)*
- *URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화되어 있지 않음.*
- 따라서 URL이 주로 쓰이게 되며, URI를 URL과 같은 의미로 보아도 큰 문제는 없음(?)

### **URL
전체 문법

- scheme://\[userinfo@]host\[:port]\[/path]\[?query]\[#fragment]
- http://www.google.com:443/search?q=hello&hl=ko

- 프로토콜 (https)
- 호스트명 (www.google.com)
- 포트 번호 (443)
- 패스 (\/search)
- 쿼리 파라미터 (\q=hello&hl=ko)

**scheme (http://)
스키마는 주로 프로토콜이 사용되고 있음
- 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
	- 예) http, https, ftp 등등
- http는 80포트, https는 443 포트를 주로 사용, =포트는 생략 가능
- https는 http에 보안 기능이 추가된 것 (HTTP Secure)

 **userinfo ()
 - URL에 사용자 정보를 포함해서 인증 받음
 - 다만, 거의 사용하지 않음

**host (www.google.com)
- 호스트명
- 도메인명 또는 IP 주소를 직접 사용 가능함

**PORT (:443)
- 접속 포트
- 일반적으로는 생략, 생략시에 http는 80, https는 443

**path (\/search)
- 리소스 경로(path), 계층적 구조
- 예)
	- \/home/file1.jpg
	- \/members
	- \/memvers/100, \/items/iphone12

**query (?q=hello&hl=ko)
- key = value 의 형태
- ?로 시작, &로 추가 가능 ?keyA=valueA&keyB=valueB
- query parameter, query string 등으로 불림, 웹 서버에 제공하는 파라미터 문자 형태

**fragment ()
- html 내부 북마크 등에 사용
- 서버에 전송하는 정보는 아님

## 웹 브라우저 요청 흐름

http://www.google.com:443/search?q=hello&hl=ko
만약 위 주소로 요청을 보낸다고 생각해보자.

![[Pasted image 20250111220605.png]]
1. 구글 서버를 찾아야하기 때문에 dns 서버에 조회를 요청함
2. DNS 서버에서 구글의 IP 주소와 포트 정보를 반환해줌
3. HTTP 요청 메시지를 생성함
	
	**HTTP 요청 메시지
	GET \/search?q=hello&hl=ko
	HTTP\/1.1 Host: www.google.com
	

![[Pasted image 20250112005701.png]]

SOCKET 라이브러리를 통해서 SYN, SYN ACK, ACK 을 통해서 구글 서버와 연결(논리적)을 하는 것.
그 이후 데이터를 아래 계층으로 전달해줌. (TCP/IP 패킷을 생성하기 위해서)

TCP/IP 패킷을 간략하게 다시 설명하면
- 출발지 IP, 출발지 PORT
- 목적지 IP, 목적지 PORT
- **전송데이터 (HTTP 메시지: GET \/search?...)

이렇게 생성된 패킷을 인터넷 망으로 전달하고 수많은 인터넷 노드들을 통해서 목적지까지 전달되게 되는 것.

구글 서버에서는 요청 패킷이 도착하면 TCP/IP 패킷을 벗겨내서 http 메시지를 해석하는 과정을 거침.

그 이후 HTTP 응답 메시지를 만들어냄.
![[Pasted image 20250112010137.png]]

이렇게 생성된 HTTP 응답 메시지는 구글 서버에서도 동일하게 응답 패킷으로 만들고 TCP/IP 패킷을 감싸는 과정을 거친 뒤, 요청자에게 다시금 전달해주게 되는 것

요청자는 받은 응답을 렌더링해서 요청 결과를 눈으로 확인할 수 있게 된다.
여기까지가 웹 브라우저의 요청 흐름

---

# 섹션 4 - HTTP 기본

## 모든 것이 HTTP
## 클라이언트 서버 구조
## Stateful, Stateless
## 비 연결성(connectionless)
## HTTP 메시지

---
# 섹션 5 - HTTP 메서드


## HTTP API를 만들어보자
## HTTP 메서드 - GET, POST
## HTTP 메서드 - PUT, PATCH, DELETE
## HTTP 메서드의 속성

---

# 섹션 6 - 

## 제목

---

# 섹션 7 - 

## 제목

---

# 섹션 8 - 

## 제목

---

# 섹션 9 - 

## 제목

---
