---
sticker: emoji//1f4c3
---
1.  **섹션 바로가기
2. [[#섹션 2 - 인터넷 네트워크]]
3. [[#섹션 3 - URI와 웹 브라우저 요청 흐름]]
4. [[#섹션 4 - HTTP 기본]]

# 섹션 2 - 인터넷 네트워크


## 인터넷 통신

**인터넷 상에서 컴퓨터 둘은 어떻게 통신할까?
![[Pasted image 20250110230849.png]]

---

## IP(인터넷 프로토콜)

**복잡한 인터넷 망
최소한의 규칙이 필요한데, 그건 바로 IP 주소 부여

**IP
인터넷 프로토콜 역할
- 지정한 IP주소에 데이터 전달
- 패킷이라는 통신 단위로 데이터 전달

**IP 패킷 정보
출발지 IP + 목적지 IP + ...

패킷을 던지면 인터넷에 있는 노드에게 전달하게 되고 노드들이 서로 통신하면서 도착지까지 도달하는 구조

**IP 프로토콜의 한계
- 비연결성
	- 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- 비신뢰성
	- 중간에 패킷이 사라지면? -> 소실되도 알 수 없음
	- 패킷이 순서대로 안오면? -> 1500byte쯤 되면 끊어서 보내게 됨
- 프로그램 구분
	- 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

### 해결방법
-> TCP/UDP 프로토콜

---

## TCP, UDP

### 인터넷 프로토콜 스택의 4계층

![[Pasted image 20250110233230.png]]


## **TCP
![[Pasted image 20250110231621.png]]

### **TCP/IP 패킷 정보
 ![[Pasted image 20250110231804.png]]

**TCP
전송 제어 프로토콜(Transmission Control Protocol)

- 연결지향 - TCP 3 way handshake(가상 연결)
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜
- 현재는 대부분 TCP 사용 중

### **TCP 3 way handshake
![[Pasted image 20250110231920.png]]
- 클라이언트, 서버 모두 서로에게 SYNC를 보내고 ACK를 보내는 구조
- 받았어? -> 응 -> 내 대답 받았어? -> 응 -> 실제 데이터 전송

**중요한 것은 이 방법을 통해서 실제로(물리적으로) 연결된 것이 아니라는 것.
-> 논리적으로 연결된 것

### **데이터 전달 보증
![[Pasted image 20250110232242.png]]



### **순서보장
![[Pasted image 20250110232308.png]]
- 기본적으로 문제가 생긴 지점부터 싹다 버린 뒤 그 부분부터 재전송을 요청함
- 물론 서버에서 내부적으로 최적화하면 해결이 가능하긴 함

**이게 왜 가능한가?
-> TCP/IP 패킷 정보를 보면 전송 제어 정보, 순서 정보, 검증 정보 등이 포함되어 있기 떄문
![[Pasted image 20250110232457.png]]

## **UDP
사용자 데이터그램 프로토콜(User Datagram Protocol)

- 하얀 도화지에 비유(기능이 거의 없음)
- 연결지향 X (TCP 3 way handshake X)
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고빠름
- ##### **정리
	- IP와 거의 같고 PORT (출발지 도착지) 정보, 체크섬(검증 데이터) 정도만 더 추가된 정도
	- 애플리케이션에서 추가적인 작업이 필요함

시간이 지나면서 사실은 영상 전송까지 거의 모든 걸 TCP가 했었는데, 이제는 UDP가 다시금 떠오르는 중.

웹 브라우저에서 HTTP 통신할 때 사용하는 HTTP 3의 스펙이 공개되었는데, 여기서 TCP/IP handshaking 과 관련해서 SYN 보내고 ACK 보내고 하는 것들까지 줄여서 최적화해보자 하는 움직임으로 UDP 프로토콜을 사용했었기 때문.

---

## **PORT
**한번에 둘 이상 연결해야 한다면?
![[Pasted image 20250110233656.png]]

여러 패킷들이 날라올텐데, 이게 게임에서 필요한 패킷인지 화상통화에서 필요한 패킷인지, 웹 브라우저에 응답 결과로 오는 패킷인지 구별할 수가 없음.

마찬가지로 보낼 때도 문제가 남게 됨.

이를 보완하기 위해서 IP에다가 '포트'라는 개념을 더해주는 것. (출발지 PORT, 목적지 PORT)
- IP는 '목적지 서버'를 찾는 것이고 서버 안에서 돌아가는 애플리케이션들을 구분하는 게 PORT

### TCP/IP 패킷

![[Pasted image 20250110234046.png]]

### PORT - 같은 IP 내에서 프로세스 구분

![[Pasted image 20250110234118.png]]
**EXAMPLE
- 200.200.200.2:11220 (게임 서버 연결)
- 200.200.200.2:32202 (화상통화 통신)
- 200.200.200.3:80 (웹 브라우저 요청)
- 100.100.100.1:10010 (웹 브라우저 요청 응답 {html})
- -> TCP/IP 패킷에는 출발지 정보도 있기 때문에 서버에서도 클라이언트에게 정확히 응답 가능

### PORT

- 0 ~ 65535 : 할당 가능
- 0 ~ 1023 : 잘 알려진 포트, 사용하는 것을 지양
	- FTP : 20, 21
	- TELNET : 23
	- HTTP : 80
	- HTTPS : 443

 

---

## DNS
**WHY USING DNS?

**IP는 기억하기 어렵다
![[Pasted image 20250110235056.png]]


**IP는 변경될 수 있다
![[Pasted image 20250110235219.png]]

### **DNS
도메인 네임 시스템 (Domain Name System)

- 전화번호부
- 도메인 명을 IP 주소로 변환

### **DNS 사용

![[Pasted image 20250110235337.png]]

- DNS 서버에 도메인을 구매해서 등록할 수 있음
- 복잡한 IP 주소 대신, 도메인 명으로 요청 가능
- 우선 도메인 명을 이용해서 DNS 서버에 요청을 보내면, DNS 서버는 해당 도메인 명과 매핑되는 IP 주소를 응답해주고, 이를 클라이언트에서 자동으로 적용해서 서버로 연결되게끔 하는 방식
- 따라서 IP 주소가 변경되더라도 DNS 서버에서만 변경해주면 클라이언트의 입장에서는 일관된 접근이 가능해지는 것

---

# 섹션 3 - URI와 웹 브라우저 요청 흐름


## URI
Uniform Resource Identifier

**URI? URL? URN?

- **URI는 로케이터(Locator), 이름(Name) 또는 둘 다 추가로 분류될 수 있다.
![[Pasted image 20250111214703.png]]

![[Pasted image 20250111214809.png]]

**URI
- **U**niform: 리소스를 식별하는 통일된 방식
- **R**esource: 자원, URI로 식별할 수 있는 모든 것 (제한 없음)
- **I**dentifier: 다른 항목과 구분하는데 필요한 정보

**URL
-  Locator: 리소스가 있는 위치를 지정

**URN
- Name: 리소스에 이름을 부여

위치는 변할 수 있지만, 이름은 변하지 않는다.

- *url:isbn:12345678(어떤 책의 isbn URN)*
- *URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화되어 있지 않음.*
- 따라서 URL이 주로 쓰이게 되며, URI를 URL과 같은 의미로 보아도 큰 문제는 없음(?)

### **URL
전체 문법

- scheme://\[userinfo@]host\[:port]\[/path]\[?query]\[#fragment]
- http://www.google.com:443/search?q=hello&hl=ko

- 프로토콜 (https)
- 호스트명 (www.google.com)
- 포트 번호 (443)
- 패스 (\/search)
- 쿼리 파라미터 (\q=hello&hl=ko)

**scheme (http://)
스키마는 주로 프로토콜이 사용되고 있음
- 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
	- 예) http, https, ftp 등등
- http는 80포트, https는 443 포트를 주로 사용, =포트는 생략 가능
- https는 http에 보안 기능이 추가된 것 (HTTP Secure)

 **userinfo ()
 - URL에 사용자 정보를 포함해서 인증 받음
 - 다만, 거의 사용하지 않음

**host (www.google.com)
- 호스트명
- 도메인명 또는 IP 주소를 직접 사용 가능함

**PORT (:443)
- 접속 포트
- 일반적으로는 생략, 생략시에 http는 80, https는 443

**path (\/search)
- 리소스 경로(path), 계층적 구조
- 예)
	- \/home/file1.jpg
	- \/members
	- \/memvers/100, \/items/iphone12

**query (?q=hello&hl=ko)
- key = value 의 형태
- ?로 시작, &로 추가 가능 ?keyA=valueA&keyB=valueB
- query parameter, query string 등으로 불림, 웹 서버에 제공하는 파라미터 문자 형태

**fragment ()
- html 내부 북마크 등에 사용
- 서버에 전송하는 정보는 아님

## 웹 브라우저 요청 흐름

http://www.google.com:443/search?q=hello&hl=ko
만약 위 주소로 요청을 보낸다고 생각해보자.

![[Pasted image 20250111220605.png]]
1. 구글 서버를 찾아야하기 때문에 dns 서버에 조회를 요청함
2. DNS 서버에서 구글의 IP 주소와 포트 정보를 반환해줌
3. HTTP 요청 메시지를 생성함
	
	**HTTP 요청 메시지
	GET \/search?q=hello&hl=ko
	HTTP\/1.1 Host: www.google.com
	

![[Pasted image 20250112005701.png]]

SOCKET 라이브러리를 통해서 SYN, SYN ACK, ACK 을 통해서 구글 서버와 연결(논리적)을 하는 것.
그 이후 데이터를 아래 계층으로 전달해줌. (TCP/IP 패킷을 생성하기 위해서)

TCP/IP 패킷을 간략하게 다시 설명하면
- 출발지 IP, 출발지 PORT
- 목적지 IP, 목적지 PORT
- **전송데이터 (HTTP 메시지: GET \/search?...)

이렇게 생성된 패킷을 인터넷 망으로 전달하고 수많은 인터넷 노드들을 통해서 목적지까지 전달되게 되는 것.

구글 서버에서는 요청 패킷이 도착하면 TCP/IP 패킷을 벗겨내서 http 메시지를 해석하는 과정을 거침.

그 이후 HTTP 응답 메시지를 만들어냄.
![[Pasted image 20250112010137.png]]

이렇게 생성된 HTTP 응답 메시지는 구글 서버에서도 동일하게 응답 패킷으로 만들고 TCP/IP 패킷을 감싸는 과정을 거친 뒤, 요청자에게 다시금 전달해주게 되는 것

요청자는 받은 응답을 렌더링해서 요청 결과를 눈으로 확인할 수 있게 된다.
여기까지가 웹 브라우저의 요청 흐름

---

# 섹션 4 - HTTP 기본

## 모든 것이 HTTP
**HTTP = HyperText Transfer Protocol

현재는 HTTP 메시지에 모든 것을 담아서 전송하고 있다.
이미지, 음성, 영상, 파일, JSON, XML, 서버간의 데이터 주고 받기 등등 거의 모든 형태의 데이터를 전송할 수 있으며, 대부분 HTTP 프로토콜을 연결해서 데이터를 전송하곤 한다.

**HTTP 역사
- HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더 X
- HTTP/1.0 1996년: 메서드, 헤더 추가
- **HTTP/1.1 1997년: 가장 많이 사용되며 우리에게 가장 중요한 버전
	- RFC2068 (1997) -> RFC2616 (1999) <1차 개정> -> **RFC7230~7235 (2014) <2차 개정>**
- HTTP/2 2015년: 성능 개선
- HTTP/3 진행 중: TCP 대신에 UDP 사용, 성능 개선


### 기반 프로토콜
- **TCP**: HTTP/1.1, HTTP/2
- **UDP**:HTTP/3
- 현재 HTTP/1.1을 주로 사용
	- HTTP/2, HTTP/3도 점점 증가 중

### HTTP 특징
- 클라이언트-서버 구조
- 무상태 프로토콜(Stateless), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

## 클라이언트 서버 구조

- Request - Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답이 오기까지 대기한다.
- 서버가 요청에 대한 결과를 만들어서 응답한다.

![[Pasted image 20250114001533.png]]
단순하지만, 클라이언트와 서버를 개념적으로 분리한 것이 중요함.

비즈니스 로직이나 데이터들은 서버에서만 처리하게끔 몰아두고, UI/UX를 클라이언트에게만 몰아두어서 각각 독립적으로 성장할 수 있는 환경을 만들어주는 것.

관심사의 분리는 효율성을 상승시키고, 집중을 초래함.


## Stateful, Stateless
**Stateful - 상태 유지

**Stateful한 시나리오**

- 고객: 이 **노트북** 얼마인가요?
- 점원: 100만원 입니다.

- 고객: **2개** 구매하겠습니다.
- 점원: 200만원 입니다. **신용카드, 현금** 중에 어떤 걸로 구매하시겠습니까?

- 고객: 신용카드로 구매하겠습니다.
- 점원: 200만원 결제 완료되었습니다.


**위와 같은 일반적인 시나리오에서, 점원이 중간에 바뀐다면?**


- 고객: 이 **노트북** 얼마인가요?
- 점원 **A**: 100만원 입니다.

- 고객: **2개** 구매하겠습니다.
- 점원 **B**: ? 무엇을 2개 구매하시나요?

- 고객: 신용카드로 구매하겠습니다.
- 점원 **C**: ? ? 무슨 제품, 몇개를 신용카드로 구매하시겠어요?


점원 B와 점원 C의 경우 고객과의 대화 속의 **문맥(Context)을** 모르기 때문에 위와 같은 문제가 발생할 수 있다.

**따라서, 정리해보자면 Stateful은,**

고객: 이 **노트북** 얼마인가요?
- 점원: 100만원 입니다.
	**(노트북 상태 유지)**

- 고객: **2개** 구매하겠습니다.
- 점원: 200만원 입니다. **신용카드, 현금** 중에 어떤 걸로 구매하시겠습니까?
	**(노트북, 2개 상태 유지)**

- 고객: 신용카드로 구매하겠습니다.
- 점원: 200만원 결제 완료되었습니다.
	**(노트북, 2개, 신용카드 상태 유지)**

상태를 유지하면서 대화하는 것을 말한다.

반대로, Stateless는 상태를 보존(유지)하지 않으면서 대화를 해야하는데,
아래와 같은 방식으로 해결할 수 있다.

- 고객: 이 **노트북** 얼마인가요?
- 점원: 100만원 입니다.

- 고객: **노트북을 2개** 구매하겠습니다.
- 점원: 노트북 2개는 200만원 입니다. **신용카드, 현금** 중에 어떤 걸로 구매하시겠습니까?

- 고객: **노트북 2개를 신용카드**로 구매하겠습니다.
- 점원: 200만원 결제 완료되었습니다.

또한, Stateless한 상태에서, 점원이 중간에 바뀐다면?

- 고객: 이 **노트북** 얼마인가요?
- 점원 **A**: 100만원 입니다.

- 고객: **노트북을 2개** 구매하겠습니다.
- 점원 **B**: 노트북 2개는 200만원 입니다. **신용카드, 현금** 중에 어떤 걸로 구매하시겠습니까?

- 고객: **노트북 2개를 신용카드**로 구매하겠습니다.
- 점원 **C**: 200만원 결제 완료되었습니다.

점원이 바뀌어도 고객의 질문 자체에서 상태를 함께 제공해주기 때문에 문제가 해결됨.

**Stateless - 무상태 프로토콜
- 서버가 클라이언트의 상태를 보존하지 않는다.
- 장점: 서버 확장성이 높아짐 (Scale Out)
- 단점: 클라이언트가 추가 데이터를 전송해주어야 한다.

이렇게 **무상태**로 개발하는 것의 장점은, 거의 무한에 가깝게 확장할 수 있다는 이점을 가진다.

### **Stateful, Stateless 차이
정리

- **상태 유지:** 중간에 다른 점원으로 바뀌면 안된다,
	- 단, 중간에 다른 점원으로 바뀔 때는 상태 정보를 다른 점원에게 미리 알려주면 괜찮다.
- **무상태:** 중간에 다른 점원으로 바뀌어도 된다.
	- 갑자기 고객이 증가한다 해도 점원을 대거 투입할 수 있음.
		- => 갑자기 클라이언트 요청이 증가한다 해도 서버를 대거 투입할 수 있음.
- 무상태는 응답 서버를 쉽게 바꿀 수 있음 -> 무한한 서버 증설 가능


#### **Stateful
![[Pasted image 20250114003642.png]]
이 상황을 확인해보면, 클라이언트 A는 곧 죽어도 서버 1과 통신을 해야만 한다.
그 외의 서버는 클라이언트 A의 상황을 모르기 때문.

따라서 Stateful 한 서버를 만든다는 것은 어려운 일이다.
만약, 서버 1에 장애가 생기게 된다면 어떻게 될까?

유지 중인 상태가 날라가면서 클라이언트 A는 다시금 다른 서버에게 처음부터 대화를 해야 한다.

#### **Stateless
![[Pasted image 20250114003850.png]]
클라이언트가 애초에 요청할 때부터 필요한 데이터를  모두 담아서 전송해주기 때문에 아무 서버나 클라이언트 A에게 응답해줄 수 있는 상황.

#### **Stateless의 실무적 한계
- 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.
- 무상태도 괜찮은 경우
	- 예) 로그인이 필요 없는 단순한 서비스 소개 화면
- 상태 유지를 무조건 해야만 하는 경우
	- 예) 로그인
- 로그인한 사용자의 경우 로그인을 했다는 상태를 서버에 유지해야만 함
- 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지해야만 함

- 상태 유지는 최소한만 사용해야만 함. 최대한 무상태로 개발해야만 함.

- 또 Stateless는 많은 데이터(노트북, 2개, 신용카드)를 보내야하는 단점도 존재함
## 비 연결성(connectionless)

#### **연결성 모델
![[Pasted image 20250114004628.png]]
![[Pasted image 20250114004639.png]]
클라이언트 1과의 통신이 끝나고 클라이언트 2로 넘어가더라도, 클라이언트 1과 서버와의 연결은 끊어지지 않음. 계속 접속되어 있는 상태.

따라서 서버는 연결을 계속 유지하며 서버의 자원을 소모시키고 있는 상태다.

장점으로는 한 번 연결하면 즉각적으로 전송이 가능하지만,
단점으로 사용하지 않는 연결이라고 해도 계속 유지해줘야해서 자원을 계속 소모해야 한다는 점이 있다.


### **비연결성 모델
![[Pasted image 20250114004914.png]]

서버는 연결을 유지하지 않으며, 최소한의 자원을 유지한다.


### **비연결성
- HTTP는 기본적으로 연결을 유지하지 않는 모델
- 일반적으로 초 단위 이하의 빠른 속도로 응담
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음 
	- 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
- 서버 자원을 매우 효율적으로 사용할 수 있음

### **비연결성의 한계와 극복
- TCP/IP 연결을 새로 맺어야 함. = 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드 됨
- 지금은 HTTP 지속 연결(Persistent Connvections)로 문제 해결
- HTTP/2, HTTP/3에서 더 많은 최적화가 이루어짐.

![[Pasted image 20250114005434.png]]

**HTTP 지속 연결(Persistent Connections) 

![[Pasted image 20250114005630.png]]


## HTTP 메시지

### 요청 메시지 / 응답 메시지

![[Pasted image 20250114005901.png]]


**구조
 
![[Pasted image 20250114005923.png]]




### 시작 라인
요청 메시지

![[Pasted image 20250114010127.png]]



![[Pasted image 20250114010344.png]]

### 시작 라인
응답 메시지
![[Pasted image 20250114013019.png]]


### 헤더

![[Pasted image 20250114013122.png]]


헤더의 용도
![[Pasted image 20250114010610.png]]
-> 메시지 본문을 제외한 모든 메타 데이터들이 포함되어 있다.


### HTTP 메시지 바디

![[Pasted image 20250114013252.png]]


---
# 섹션 5 - HTTP 메서드


## HTTP API를 만들어보자

**요구사항  
회원 정보 관리 API를 만들어라.
- 회원 목록 조회
- 회원 조회
- 회원 등록
- 회원 수정
- 회원 삭제

**API URI 설계
URI(Uniform Resource Identifier)
- 회원 목록 조회 /read-member-list
- 회원 조회 /read-member-by-id
- 회원 등록 /create-member
- 회원 수정 /update-member
- 회원 삭제 /delete-member

#### 이것이 좋은 URI 설계일까?

### 가장 중요한 것은, **리소스 식별

- 리소스의 의미는 뭘까?
	- 회원을 등록하고 수정하고 조회하는게 리소스가 아니다!
	- 예) 미네랄을 캐라 -> 미네랄이 리소스
	- 즉, **회원이라는 개념 자체가 바로 리소스다.
- 리소스를 어떻게 식별하는게 좋을까?
	- 회원을 등록하고 수정하고 조회하는 것을 모두 배제
	- **회원이라는 리소스만 식별하면 된다 -> 회원 리소스를 URI에 매핑**

**API URI 설계
URI(Uniform Resource Identifier)
- **회원** 목록 조회 /members
- **회원** 조회 /members/{id} \[GET]
- **회원** 등록 /members/{id} \[POST]
- **회원** 수정 /members/{id} \[PUT]
- **회원** 삭제 /members/{id} \[DELETE]
- 계층 구조상 상위를 컬렉션으로 보고 복수 단어를 사용하는 것을 권장 (member -> members)

**가장 중요한 것은 리소스를 식별하는 것.
- **URI는 리소스만 식별한다.**
- 리소스와 해당 리소스를 대상으로 하는 **행위**를 분리해야만 함.
	- 리소스: 회원
	- 행위: 조회, 등록, 삭제, 변경
- 리소스는 명사, 횅위는 동사 (미네랄을 캐라)
- 행위(메서드)는 어떻게 구분하면 될까?

## HTTP 메서드 - GET, POST

#### HTTP 메서드 종류
**주요 메서드
- GET: 리소스 조회
- POST: 요청 데이터 처리, 주로 등록에 사용함
- PUT: 리소스를 대체, 해당 리소스가 없으면 생성함
- PATCH: 리소스 부분 변경
- DELETE: 리소스 삭제

**기타 메서드
- HEAD: GET과 동일하지만, 메시지 부분을 제외하고 상태 줄과 헤더만 반환함
- OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용함)
- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

### GET
> **GET /search?q=hello&hl=ko HTTP/1.1
> Host: www.google.com
- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음

### POST
> POST /members HTTP/1.1
> Content-Type: application/json
> {
> 	"username": "hello",
> 	"age": 20
> }
- 요청 데이터 처리
- **메시지 바디를 통해 서버로 요청 데이터 전달
- 서버는 요청 데이터를 처리
	- 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행함
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용함

**POST) 요청 데이터를 어떻게 처리한다는 뜻일까?
- 스펙: POST 메서드는 대상 리소스가 리소소의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청함.
	- HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공
		- 예) HTML FORM에 입력한 정보로 회원 가입, 주문 등에서 사용
	- 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시
		- 예) 게시판 글쓰기, 댓글 달기
	- 서버가 아직 식별하지 않은 새 리소스 생성
		- 예) 신규 주문 생성
	- 기존 자원에 데이터 추가
		- 예) 한 문서 끝에 내용 추가하기
- **정리: 이 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함. -> 정해진 것이 없다는 말

#### POST
- **1. 새 리소스 생성(등록)**
	- 서버가 아직 식별하지 않은 새 리소스 생성
- **2. 요청 데이터 처리**
	- 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우
		- 예) 주문에서 결제 완료 -> 배달 시작 -> 배달 완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
	- POST의 결과로 새로운 리소스가 생성되지 않을 수 있음
		- 예) POST /orders/{orderId}/start-delivery **(컨트롤 URI)**
- **3. 다른 메서드로 처리하기 애매한 경우**
	- 예) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우
	- 애매하면 POST

## HTTP 메서드 - PUT, PATCH, DELETE

#### **PUT
- 리소스를 대체
	- 리소스가 있으면 대체
	- 리소스가 없으면 생성
	- 쉽게 이야기해서 덮어버림
- 중요! 클라이언트가 리소스를 식별
	- 클라이언트가 리소스 위치를 알고 URI를 지정
	- POST와 차이점
		- POST는 리소스의 위치를 알지 못하는 반면, PUT은 알고있기 때문에 애초부터 /members/100 과 같이 접근함.

- 주의! 리소스를 완전히 대체한다!
- ![[Pasted image 20250115150015.png]]


- ![[Pasted image 20250115150131.png]]

기존걸 완전히 부수고 새롭게


#### **PATCH
> PATCH /members/100 HTTP/1.1
> Content-Type: application/json
> {
> 	"age - 50"
> }

- 리소스 부분 변경

#### **DELETE
> DELETE /members/100 HTTP/1.1
> Host: localhost:8080

- 리소스 제거

## HTTP 메서드의 속성

- 안전(Safe Methods)
- 멱등(Idempotent Methods)
- 캐시가능(Cacgeable Methods)

![[Pasted image 20250115152040.png]]

#### **안전
Safe

- 호출해도 리소스를 변경하지 않는다.
- 그래도 계속 호출해서, 로그 같은게 쌓여서 장애가 발생하면요?
- A: 안전은 해당 리소스만을 고려한다. 그런 부분까지 고려하지 않는다.


#### **멱등
Idempotent

- f(f(x)) = f(x)
- 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다.
- 멱등 메서드
	- **GET:** 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다.
	- **PUT:** 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.
	- **DELETE:** 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
	- **POST:** 멱등이 아니다! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.

**왜 멱등이라는 개념이 필요한가?
- 활용
	- 자동 복구 메커니즘
		- "서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가?" 에 대한 판단 근거가 되어줌.

- **Q: 재요청 중간에 다른 곳에서 리소스를 변경해버리면?
	- 사용자1: GET -> username:A, age:20
	- 사용자2: PUT -> username:A, age:30
	- 사용자1: GET -> username:A, age:30 -> 사용자2의 영향으로 바뀐 데이터 조회
- **A:멱등은 외부 요인으로 중간에 리소스가 변경되는 것까지는 고려하지 않는다.

#### **캐시가능
Chacheable

- 응답 결과 리소스를 캐시해서 사용해도 되는가?
- GET, HEAD, POST, PATCH 캐시 가능
- 실제로는 GET, HEAD 정도만 캐시로 사용
	- POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음



---

# 섹션 6 - HTTP 메서드 활용

## 클라이언트에서 서버로 데이터 전송

- 쿼리 파라미터를 통한 데이터 전송
	- GET
	- 주로 정렬 필터 (검색어)
- 메시지 바디를 통한 데이터 전송
	- POST, PUT, PATCH
	- 회원 가입, 상품 주문, 리소스 등록, 리소스 변경

**4가지 상황
- **정적 데이터 조회
	- 이미지, 정적 텍스트 문서
![[Pasted image 20250116092010.png]]
- 조회는 GET 사용
- 정적 데이터는 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능

- **동적 데이터 조회
	- 주로 검색, 게시판 목록에서 정렬 필터 (검색어)
![[Pasted image 20250116092122.png]]
- 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에서 주로 사용
- 조회는 GET 사용
- GET은 쿼리 파라미터 사용해서 데이터를 전달


- **HTML Form을 통한 데이터 전송
	- 회원 가입, 상품 주문, 데이터 변경
![[Pasted image 20250116092343.png]]

좋지 않은 예
![[Pasted image 20250116092616.png]]

파일을 전송할 때
![[Pasted image 20250116092726.png]]

**정리
- HTML Form submit시에 POST로 전송
	- 예) 회원 가입, 상품 주문, 데이터 변경
- Content-Type: application/x-www-form-urlencoded 사용
	- form의 내용을 **메시지 바디**를 통해서 전송(key=value, 쿼리 파라미터 형식)
	- 전송 데이터를 url encoding 처리
		- 예) abc김 -> abc%EA%B9%80
- HTML Form은 GET 전송도 가능 (저장하는 작업 등에는 사용 X, 쿼리 파라미터 형식)
- Content-Type: multipart/form-data
	- 파일 업로드 같은 바이너리 데이터 전송시에 사용
	- 다른 종류의 여러 파일과 폼의 내용을 함께 전송 가능 (그래서 이름이 multipart)
- 참고: HTML Form 전송은 GET, POST만 지원


- **HTTP API를 통한 데이터 전송
	- 회원 가입, 상품 주문, 데이터 변경
	- 서버 to 서버, 앱 클라이언트, 웹 클라이언트(Ajax)
![[Pasted image 20250116093332.png]]
- 직접 만들어서 넘겨주면 된다

**정리
- **서버 to 서버**
	- 백엔드 시스템 통신
- **앱 클라이언트**
	- 아이폰, 안드로이드
- **웹 클라이언트**
	- HTML에서 Form 전송 대신 자바 스크립트를 통한 통신에 사용(**AJAX**)
	- 예) React, Vue.JS 같은 웹 클라이언트와 API 통신
- POST, PUT, PATCH: 메시지 바디를 통해 데이터 전송
- GET: 조회, 쿼리 파라미터로 데이터 전달
- Content-Type: application/json을 주로 사용 (사실상 표준)
	- TEXT, XML, JSON 등등

## HTTP API 설계 예시
- **HTTP API - 컬렉션
	- **POST 기반 등록
	- 예) 회원 관리 API 제공
- **HTTP API - 스토어
	- **PUT 기반 등록
	- 예) 정적 컨텐츠 관리, 원격 파일 관리
- **HTML FORM 사용
	- 웹 페이지 회원 관리
	- GET, POST만 지원


#### **회원 관리 시스템
API 설계 - POST 기반 등록

- **회원** 목록 /members -> **GET
- **회원** 등록 /members -> **POST
- **회원** 조회 / members/{id} -> **GET
- **회원** 수정 /members/{id} -> **PATCH, PUT, POST
- **회원** 삭제 /members/{id} -> **DELETE

##### POST - 신규 자원 등록 특징
- 클라이언트는 등록될 리소스의 URI를 모른다.
	- 회원 등록 /members -> POST
	- POST / members
- 서버가 새로 등록된 리소스 URI를 생성해준다.
	- HTTP/1.1 201 Created
	  Location: /members/100
- 컬렉션(Collection)
	- 서버가 관리하는 리소스 디렉토리
	- 서버가 리소스의 URI를 생성하고 관리
	- 여기서 컬렉션은 /members


---

# 섹션 7 - HTTP 상태코드

## 제목

---

# 섹션 8 - HTTP 헤더1 - 일반 헤더

## 제목

---

# 섹션 9 - HTTP 헤더2 - 캐시와 조건부 요청

## 제목

---
